!! SmaCC Transformations

Once you have generated your AST using SmaCC, you may want to use SmaCC's built-in tools to transform the AST.
For example, transforming the AST may make it easier to generate code. 


!!! Defining Transformations 

Let's add support for transforming the simple expression ASTs generated from our calculator example.  
The basic idea is to define ''patterns'' that match subtrees of the AST, and specify how these subtrees should be re-written.

We start by extending our grammar with two additional lines. 

- The first line defines how we will write a pattern in our grammar.  SmaCC doesn't have a built-in pattern syntax, because whatever SmaCC were to choose might conflict with the syntax of your language.  Instead, your grammar should define the ==<patternToken>==: SmaCC uses this regular expression as the definition of a pattern. For our example language, we will define a pattern as anything enclosed by ==`== characters (e.g., ==`pattern`==).  This same choice would work for any language that does not use ==`== frequently in its syntax.
- The second line we need to add tells SmaCC to generate a GLR parser (==%glr;==). This allows SmaCC to parse all possible representations of a pattern expression. 

Here is our grammar with those two additional lines:

[[[
	<number> : [0-9]+ (\. [0-9]*) ? ;
	<name> : [a-zA-Z]\w*;
	<whitespace> : \s+;

+	<patternToken> : \` [^\`]* \` ;
+	%glr;

	%left "+" "-";
	%left "*" "/";
	%right "^";
	%annotate_tokens;
	%root Expression;
	%prefix AST;
	%suffix Node;
	%ignore_variables leftParenToken rightParenToken;

	Expression 
		: Expression 'left' "+" 'operator' Expression 'right' {{Binary}}
		| Expression 'left' "-" 'operator' Expression 'right' {{Binary}}
		| Expression 'left' "*" 'operator' Expression 'right' {{Binary}}
		| Expression 'left' "/" 'operator' Expression 'right' {{Binary}}
		| Expression 'left' "^" 'operator' Expression 'right' {{Binary}}
		| "(" Expression ")" {{}}
		| Number
		| Function;
	Number : <number> {{Number}};
	Function
		: <name> "(" 'leftParen' _Arguments ")" 'rightParen' {{}};
	_Arguments
		:
		| Arguments;
	Arguments
		: Expression 'argument'
		| Arguments "," Expression 'argument';
]]]



!!! Pattern matching expressions

Having made these changes, we can now define ''re-write rules'' that specify how certain subtrees in the AST should be replaced by other subtrees.  To do this, we modify our grammar by adding some pattern-matching expressions. Pattern-matching expressions look like normal expressions, but may include patterns that are surrounded by the back quote, ==`==, character. 

For example, ==`a` \+ 1== is a pattern-matching expression that matches any expression followed by ==\+ 1==.

Once the pattern has matched a subtree, we transform it into a new subtree.  To do this, we supply a replacement expression that uses the pattern variables from the match. Replacement expressions are strings that can contain back-quoted variables. These back-quoted variables are replaced with the appropriate subtree from the pattern. 

For example, if we are searching for the pattern ==`a` \+ 1==, we can supply a replacement expression like ==1 \+ `a`==. This pattern will match ==(3 \+ 4) \+ 1==. When we perform the replacement we take the literal ==1 \+ == part of the string and append the value of the subtree that matched ==`a`==. In this case, we would append ==(3 \+ 4)== to give us ==1 \+ (3 \+ 4)==.

!!! Example
As an example, let's rewrite addition expressions into reverse Polish notation. Our search pattern is ==`a` \+ `b`== and our replacement expression is ==`a` `b` \+==.

[[[
	| rewriter compositeRewrite rewrite matcher transformation |
	compositeRewrite := SmaCCRewriteFile new.
	compositeRewrite parserClass: CalculatorParser.
	matcher := SmaCCRewriteTreeMatch new.
	matcher source: '`a` + `b`'.
	transformation := SmaCCRewriteStringTransformation new.
	transformation string: '`a` `b` +'.
	rewrite := SmaCCRewrite 
		comment: 'Postfix rewriter' 
		match: matcher
		transformation: transformation.
	compositeRewrite addTransformation: rewrite.
	rewriter := SmaCCRewriteEngine new.
	rewriter rewriteRule: compositeRewrite.
	rewriter rewriteTree: (CalculatorParser parse: '(3 + 4) + (4 + 3)')
]]]



This code rewrites ==(3 \+ 4) \+ (4 \+ 3)== in RPN format and returns ==3 4 \+ 4 3 \+ \+==. The first match that this finds is ==`a`== = ==(3 \+ 4)== and ==`b`== = ==(4 \+ 3)==. Inside our replacement expression, we refer to ==`a`== and ==`b`==, so we first process those expression for more transformations. Since both contain other addition expressions, we rewrite both expressions to get ==`a`== = ==3 4 \+== and ==`b`== = ==4 3 \+==.

Here's the same example, using SmaCC's special rewrite syntax.

[[[
	| rewriter rewriteExpression |
	rewriteExpression := 
		'Parser: CalculatorParser
		>>>`a` + `b`<<<
		->
		>>>`a` `b` +<<<'.
	rewriter := SmaCCRewriteEngine new.
	rewriter rewriteRule: (SmaCCRewriteRuleFileParser parse: rewriteExpression).
	rewriter rewriteTree: (CalculatorParser parse: '(3 + 4) + (4 + 3)')
]]]


!!! Parametrizing Transformations
Let's extend our RPN rewriter to support other expressions besides addition. We could do that by providing rewrites for all possible operators (\+, -, \*, /, ^), but it would be better if we could do it with a pattern. You might think that we could use ==`a` `op` `b`==, but the pattern ==`op`== will match only AST nodes, and not tokens like ==(\+)==. We can tell SmaCC to match tokens by using ==`a` `op{beToken}` `b`==. Here's the rewrite expression that works for all expressions:

[[[
	Parser: CalculatorParser
	\>\>\>`a` `op{beToken}` `b`\<\<\<
	->
	\>\>\>`a` `b` `op`\<\<\<
]]]

If we transform ==(3 \+ 4) \* (5 - 2) ^ 3==, we'll get ==3 4 \+ 5 2 - 3 ^ \*==.
